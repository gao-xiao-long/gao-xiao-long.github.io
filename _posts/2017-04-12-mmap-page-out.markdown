---                                                                                                    
layout: post                                                                                           
title: 使用mmap文件映射导致平响异常情况分析                                                                   
date: 2017-03-18                                                                                       
author: "gao-xiao-long"                                                                                
catalog: true                                                                                          
tags:                                                                                                  
    - 基础技术                                                                                          
---       
内部某检索系统使用了mmap文件映射的方式加载正排索引及倒排索引。部署方式为物理机独立部署，线上运行了很长时间都很稳定。最近在迁移到公司内虚拟化平台时(类似Docker)却发现性能波动很大，经常出现平响飙升的情况。经过排查发现平响飙升的原因是由于mmap使用的Page Cache被换出到磁盘导致(下面是出问题时间点Mem Cache及Mem Free的变化)。排查期间对内核内存管理机制有了更进一步的的理解，特粗略记录下来。

![图](/img/in-post/mem-cache.png)

#### 基础

1. 使用mmap将文件映射到物理内存时，内核将其加载到Page Cache，Page Cache主要作用是缓存文件数据。当系统内存不足是，Page Cache中的数据是可以换出到磁盘中的。Linux中通过top命令可以查看使用的内存有多少是Page Cache占用的。(RES表示程序实际占用内存，**SHR部分**则表示使用了Page Cache的内存。）
 ![图](/img/in-post/top-cache.png)
2. Linux内核的基本设计决策之一是：缓存通常不是固定长度的，可以动态增长，直到用尽所有的物理内存。向物理内存填充信息是件好事，因为未使用的内存实际上是资源的浪费，但是内核需要有一种机制，以便在有更紧急的任务需要内存时能够收缩缓存。
3. 更多基础知识可以参考：[理解文件IO](http://gao-xiao-long.github.io/2016/04/13/file-io/)

#### Page Cache何时换出到磁盘
Page Cache换出到磁盘触发条件有两个
1. 内核检测到某个操作期间内存严重不足(主要是动态分配内存期间，如调用malloc()或new())，将调用trye_to_free_pages,该函数检查当前内存域中的所有野，并释放最不常用的那些（此操作可能会阻塞应用程序）
2. 一个名为kswapd后台守护进程，会定期检查内存的使用情况，当发现内存达到某一阈值时，会换出部分页(内核通过LRU算法管理页，会优先淘汰不活跃的页)，以防止内核在执行其他操作期间(如new)发现内存不足。

当使用mmap映射的程序在物理机独立部署时，一来内存足够，触发Page Cache换出的可能性比较小，二来即使服务频繁重启导致Page Cache过大引发换出，也是换出一些过时的数据，新映射的mmap文件不会换出。故程序表现
一直很稳定，然而如果部署在虚拟化平台时，模块会出现因为其他程序占用内存过高(虚拟化平台中内存为软限，程序占用内存过高不会OOM)导致Page Cache被换出的情况，进而影响检索性能。

#### 如何解决
主要有两个方法可以解决Page Cache换出问题

1. 使用MMAP映射时指定MAP_LOCKED参数：指定此参数是会调用mlock()将内存区域锁定，防止被换出到磁盘，但是如果不是root账号只能锁定RLIMIT_MEMLOCK内存(x86_64下默认为64K)，需要调大此参数或修改为ulimited
2. 修改业务逻辑代码，增加全内存加载选项：虽然向系统动态申请大内存时，也是通过mmap方式，但采用的是匿名映射，不与具体文件绑定，不会占用Page Cache，故不存在换出的问题。

参考：

深入Linux内核架构

[Kernel Documents/mmap](http://kernel.taobao.org/index.php?title=Kernel_Documents/mmap_18_32)
